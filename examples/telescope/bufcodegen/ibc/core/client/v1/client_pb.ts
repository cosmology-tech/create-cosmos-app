// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file ibc/core/client/v1/client.proto (package ibc.core.client.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Plan } from "../../../../cosmos/upgrade/v1beta1/upgrade_pb.js";

/**
 * IdentifiedClientState defines a client state with an additional client
 * identifier field.
 *
 * @generated from message ibc.core.client.v1.IdentifiedClientState
 */
export class IdentifiedClientState extends Message<IdentifiedClientState> {
  /**
   * client identifier
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * client state
   *
   * @generated from field: google.protobuf.Any client_state = 2;
   */
  clientState?: Any;

  constructor(data?: PartialMessage<IdentifiedClientState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.IdentifiedClientState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "client_state", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifiedClientState {
    return new IdentifiedClientState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifiedClientState {
    return new IdentifiedClientState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifiedClientState {
    return new IdentifiedClientState().fromJsonString(jsonString, options);
  }

  static equals(a: IdentifiedClientState | PlainMessage<IdentifiedClientState> | undefined, b: IdentifiedClientState | PlainMessage<IdentifiedClientState> | undefined): boolean {
    return proto3.util.equals(IdentifiedClientState, a, b);
  }
}

/**
 * ConsensusStateWithHeight defines a consensus state with an additional height
 * field.
 *
 * @generated from message ibc.core.client.v1.ConsensusStateWithHeight
 */
export class ConsensusStateWithHeight extends Message<ConsensusStateWithHeight> {
  /**
   * consensus state height
   *
   * @generated from field: ibc.core.client.v1.Height height = 1;
   */
  height?: Height;

  /**
   * consensus state
   *
   * @generated from field: google.protobuf.Any consensus_state = 2;
   */
  consensusState?: Any;

  constructor(data?: PartialMessage<ConsensusStateWithHeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.ConsensusStateWithHeight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "message", T: Height },
    { no: 2, name: "consensus_state", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusStateWithHeight | PlainMessage<ConsensusStateWithHeight> | undefined, b: ConsensusStateWithHeight | PlainMessage<ConsensusStateWithHeight> | undefined): boolean {
    return proto3.util.equals(ConsensusStateWithHeight, a, b);
  }
}

/**
 * ClientConsensusStates defines all the stored consensus states for a given
 * client.
 *
 * @generated from message ibc.core.client.v1.ClientConsensusStates
 */
export class ClientConsensusStates extends Message<ClientConsensusStates> {
  /**
   * client identifier
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * consensus states and their heights associated with the client
   *
   * @generated from field: repeated ibc.core.client.v1.ConsensusStateWithHeight consensus_states = 2;
   */
  consensusStates: ConsensusStateWithHeight[] = [];

  constructor(data?: PartialMessage<ClientConsensusStates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.ClientConsensusStates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "consensus_states", kind: "message", T: ConsensusStateWithHeight, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientConsensusStates {
    return new ClientConsensusStates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientConsensusStates {
    return new ClientConsensusStates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientConsensusStates {
    return new ClientConsensusStates().fromJsonString(jsonString, options);
  }

  static equals(a: ClientConsensusStates | PlainMessage<ClientConsensusStates> | undefined, b: ClientConsensusStates | PlainMessage<ClientConsensusStates> | undefined): boolean {
    return proto3.util.equals(ClientConsensusStates, a, b);
  }
}

/**
 * ClientUpdateProposal is a governance proposal. If it passes, the substitute
 * client's latest consensus state is copied over to the subject client. The proposal
 * handler may fail if the subject and the substitute do not match in client and
 * chain parameters (with exception to latest height, frozen height, and chain-id).
 *
 * @generated from message ibc.core.client.v1.ClientUpdateProposal
 */
export class ClientUpdateProposal extends Message<ClientUpdateProposal> {
  /**
   * the title of the update proposal
   *
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * the description of the proposal
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * the client identifier for the client to be updated if the proposal passes
   *
   * @generated from field: string subject_client_id = 3;
   */
  subjectClientId = "";

  /**
   * the substitute client identifier for the client standing in for the subject
   * client
   *
   * @generated from field: string substitute_client_id = 4;
   */
  substituteClientId = "";

  constructor(data?: PartialMessage<ClientUpdateProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.ClientUpdateProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subject_client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "substitute_client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientUpdateProposal {
    return new ClientUpdateProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientUpdateProposal {
    return new ClientUpdateProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientUpdateProposal {
    return new ClientUpdateProposal().fromJsonString(jsonString, options);
  }

  static equals(a: ClientUpdateProposal | PlainMessage<ClientUpdateProposal> | undefined, b: ClientUpdateProposal | PlainMessage<ClientUpdateProposal> | undefined): boolean {
    return proto3.util.equals(ClientUpdateProposal, a, b);
  }
}

/**
 * UpgradeProposal is a gov Content type for initiating an IBC breaking
 * upgrade.
 *
 * @generated from message ibc.core.client.v1.UpgradeProposal
 */
export class UpgradeProposal extends Message<UpgradeProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: cosmos.upgrade.v1beta1.Plan plan = 3;
   */
  plan?: Plan;

  /**
   * An UpgradedClientState must be provided to perform an IBC breaking upgrade.
   * This will make the chain commit to the correct upgraded (self) client state
   * before the upgrade occurs, so that connecting chains can verify that the
   * new upgraded client is valid by verifying a proof on the previous version
   * of the chain. This will allow IBC connections to persist smoothly across
   * planned chain upgrades
   *
   * @generated from field: google.protobuf.Any upgraded_client_state = 4;
   */
  upgradedClientState?: Any;

  constructor(data?: PartialMessage<UpgradeProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.UpgradeProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "plan", kind: "message", T: Plan },
    { no: 4, name: "upgraded_client_state", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeProposal {
    return new UpgradeProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeProposal {
    return new UpgradeProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeProposal {
    return new UpgradeProposal().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeProposal | PlainMessage<UpgradeProposal> | undefined, b: UpgradeProposal | PlainMessage<UpgradeProposal> | undefined): boolean {
    return proto3.util.equals(UpgradeProposal, a, b);
  }
}

/**
 * Height is a monotonically increasing data type
 * that can be compared against another Height for the purposes of updating and
 * freezing clients
 *
 * Normally the RevisionHeight is incremented at each height while keeping
 * RevisionNumber the same. However some consensus algorithms may choose to
 * reset the height in certain conditions e.g. hard forks, state-machine
 * breaking changes In these cases, the RevisionNumber is incremented so that
 * height continues to be monitonically increasing even as the RevisionHeight
 * gets reset
 *
 * @generated from message ibc.core.client.v1.Height
 */
export class Height extends Message<Height> {
  /**
   * the revision that the client is currently on
   *
   * @generated from field: uint64 revision_number = 1;
   */
  revisionNumber = protoInt64.zero;

  /**
   * the height within the given revision
   *
   * @generated from field: uint64 revision_height = 2;
   */
  revisionHeight = protoInt64.zero;

  constructor(data?: PartialMessage<Height>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.Height";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "revision_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "revision_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Height {
    return new Height().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Height {
    return new Height().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Height {
    return new Height().fromJsonString(jsonString, options);
  }

  static equals(a: Height | PlainMessage<Height> | undefined, b: Height | PlainMessage<Height> | undefined): boolean {
    return proto3.util.equals(Height, a, b);
  }
}

/**
 * Params defines the set of IBC light client parameters.
 *
 * @generated from message ibc.core.client.v1.Params
 */
export class Params extends Message<Params> {
  /**
   * allowed_clients defines the list of allowed client state types.
   *
   * @generated from field: repeated string allowed_clients = 1;
   */
  allowedClients: string[] = [];

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ibc.core.client.v1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed_clients", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

