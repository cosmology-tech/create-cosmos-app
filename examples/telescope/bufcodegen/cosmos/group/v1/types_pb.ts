// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file cosmos/group/v1/types.proto (package cosmos.group.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * VoteOption enumerates the valid vote options for a given proposal.
 *
 * @generated from enum cosmos.group.v1.VoteOption
 */
export enum VoteOption {
  /**
   * VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
   *
   * @generated from enum value: VOTE_OPTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * VOTE_OPTION_YES defines a yes vote option.
   *
   * @generated from enum value: VOTE_OPTION_YES = 1;
   */
  YES = 1,

  /**
   * VOTE_OPTION_ABSTAIN defines an abstain vote option.
   *
   * @generated from enum value: VOTE_OPTION_ABSTAIN = 2;
   */
  ABSTAIN = 2,

  /**
   * VOTE_OPTION_NO defines a no vote option.
   *
   * @generated from enum value: VOTE_OPTION_NO = 3;
   */
  NO = 3,

  /**
   * VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
   *
   * @generated from enum value: VOTE_OPTION_NO_WITH_VETO = 4;
   */
  NO_WITH_VETO = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(VoteOption)
proto3.util.setEnumType(VoteOption, "cosmos.group.v1.VoteOption", [
  { no: 0, name: "VOTE_OPTION_UNSPECIFIED" },
  { no: 1, name: "VOTE_OPTION_YES" },
  { no: 2, name: "VOTE_OPTION_ABSTAIN" },
  { no: 3, name: "VOTE_OPTION_NO" },
  { no: 4, name: "VOTE_OPTION_NO_WITH_VETO" },
]);

/**
 * ProposalStatus defines proposal statuses.
 *
 * @generated from enum cosmos.group.v1.ProposalStatus
 */
export enum ProposalStatus {
  /**
   * An empty value is invalid and not allowed.
   *
   * @generated from enum value: PROPOSAL_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Initial status of a proposal when persisted.
   *
   * @generated from enum value: PROPOSAL_STATUS_SUBMITTED = 1;
   */
  SUBMITTED = 1,

  /**
   * Final status of a proposal when the final tally was executed.
   *
   * @generated from enum value: PROPOSAL_STATUS_CLOSED = 2;
   */
  CLOSED = 2,

  /**
   * Final status of a proposal when the group was modified before the final tally.
   *
   * @generated from enum value: PROPOSAL_STATUS_ABORTED = 3;
   */
  ABORTED = 3,

  /**
   * A proposal can be deleted before the voting start time by the owner. When this happens the final status
   * is Withdrawn.
   *
   * @generated from enum value: PROPOSAL_STATUS_WITHDRAWN = 4;
   */
  WITHDRAWN = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ProposalStatus)
proto3.util.setEnumType(ProposalStatus, "cosmos.group.v1.ProposalStatus", [
  { no: 0, name: "PROPOSAL_STATUS_UNSPECIFIED" },
  { no: 1, name: "PROPOSAL_STATUS_SUBMITTED" },
  { no: 2, name: "PROPOSAL_STATUS_CLOSED" },
  { no: 3, name: "PROPOSAL_STATUS_ABORTED" },
  { no: 4, name: "PROPOSAL_STATUS_WITHDRAWN" },
]);

/**
 * ProposalResult defines types of proposal results.
 *
 * @generated from enum cosmos.group.v1.ProposalResult
 */
export enum ProposalResult {
  /**
   * An empty value is invalid and not allowed
   *
   * @generated from enum value: PROPOSAL_RESULT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Until a final tally has happened the status is unfinalized
   *
   * @generated from enum value: PROPOSAL_RESULT_UNFINALIZED = 1;
   */
  UNFINALIZED = 1,

  /**
   * Final result of the tally
   *
   * @generated from enum value: PROPOSAL_RESULT_ACCEPTED = 2;
   */
  ACCEPTED = 2,

  /**
   * Final result of the tally
   *
   * @generated from enum value: PROPOSAL_RESULT_REJECTED = 3;
   */
  REJECTED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ProposalResult)
proto3.util.setEnumType(ProposalResult, "cosmos.group.v1.ProposalResult", [
  { no: 0, name: "PROPOSAL_RESULT_UNSPECIFIED" },
  { no: 1, name: "PROPOSAL_RESULT_UNFINALIZED" },
  { no: 2, name: "PROPOSAL_RESULT_ACCEPTED" },
  { no: 3, name: "PROPOSAL_RESULT_REJECTED" },
]);

/**
 * ProposalExecutorResult defines types of proposal executor results.
 *
 * @generated from enum cosmos.group.v1.ProposalExecutorResult
 */
export enum ProposalExecutorResult {
  /**
   * An empty value is not allowed.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * We have not yet run the executor.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1;
   */
  NOT_RUN = 1,

  /**
   * The executor was successful and proposed action updated state.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2;
   */
  SUCCESS = 2,

  /**
   * The executor returned an error and proposed action didn't update state.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_FAILURE = 3;
   */
  FAILURE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ProposalExecutorResult)
proto3.util.setEnumType(ProposalExecutorResult, "cosmos.group.v1.ProposalExecutorResult", [
  { no: 0, name: "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED" },
  { no: 1, name: "PROPOSAL_EXECUTOR_RESULT_NOT_RUN" },
  { no: 2, name: "PROPOSAL_EXECUTOR_RESULT_SUCCESS" },
  { no: 3, name: "PROPOSAL_EXECUTOR_RESULT_FAILURE" },
]);

/**
 * Member represents a group member with an account address,
 * non-zero weight and metadata.
 *
 * @generated from message cosmos.group.v1.Member
 */
export class Member extends Message<Member> {
  /**
   * address is the member's account address.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * weight is the member's voting weight that should be greater than 0.
   *
   * @generated from field: string weight = 2;
   */
  weight = "";

  /**
   * metadata is any arbitrary metadata to attached to the member.
   *
   * @generated from field: string metadata = 3;
   */
  metadata = "";

  /**
   * added_at is a timestamp specifying when a member was added.
   *
   * @generated from field: google.protobuf.Timestamp added_at = 4;
   */
  addedAt?: Timestamp;

  constructor(data?: PartialMessage<Member>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.Member";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "added_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Member {
    return new Member().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJsonString(jsonString, options);
  }

  static equals(a: Member | PlainMessage<Member> | undefined, b: Member | PlainMessage<Member> | undefined): boolean {
    return proto3.util.equals(Member, a, b);
  }
}

/**
 * Members defines a repeated slice of Member objects.
 *
 * @generated from message cosmos.group.v1.Members
 */
export class Members extends Message<Members> {
  /**
   * members is the list of members.
   *
   * @generated from field: repeated cosmos.group.v1.Member members = 1;
   */
  members: Member[] = [];

  constructor(data?: PartialMessage<Members>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.Members";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "members", kind: "message", T: Member, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Members {
    return new Members().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Members {
    return new Members().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Members {
    return new Members().fromJsonString(jsonString, options);
  }

  static equals(a: Members | PlainMessage<Members> | undefined, b: Members | PlainMessage<Members> | undefined): boolean {
    return proto3.util.equals(Members, a, b);
  }
}

/**
 * ThresholdDecisionPolicy implements the DecisionPolicy interface
 *
 * @generated from message cosmos.group.v1.ThresholdDecisionPolicy
 */
export class ThresholdDecisionPolicy extends Message<ThresholdDecisionPolicy> {
  /**
   * threshold is the minimum weighted sum of yes votes that must be met or exceeded for a proposal to succeed.
   *
   * @generated from field: string threshold = 1;
   */
  threshold = "";

  /**
   * windows defines the different windows for voting and execution.
   *
   * @generated from field: cosmos.group.v1.DecisionPolicyWindows windows = 2;
   */
  windows?: DecisionPolicyWindows;

  constructor(data?: PartialMessage<ThresholdDecisionPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.ThresholdDecisionPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "threshold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "windows", kind: "message", T: DecisionPolicyWindows },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThresholdDecisionPolicy {
    return new ThresholdDecisionPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThresholdDecisionPolicy {
    return new ThresholdDecisionPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThresholdDecisionPolicy {
    return new ThresholdDecisionPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: ThresholdDecisionPolicy | PlainMessage<ThresholdDecisionPolicy> | undefined, b: ThresholdDecisionPolicy | PlainMessage<ThresholdDecisionPolicy> | undefined): boolean {
    return proto3.util.equals(ThresholdDecisionPolicy, a, b);
  }
}

/**
 * PercentageDecisionPolicy implements the DecisionPolicy interface
 *
 * @generated from message cosmos.group.v1.PercentageDecisionPolicy
 */
export class PercentageDecisionPolicy extends Message<PercentageDecisionPolicy> {
  /**
   * percentage is the minimum percentage the weighted sum of yes votes must meet for a proposal to succeed.
   *
   * @generated from field: string percentage = 1;
   */
  percentage = "";

  /**
   * windows defines the different windows for voting and execution.
   *
   * @generated from field: cosmos.group.v1.DecisionPolicyWindows windows = 2;
   */
  windows?: DecisionPolicyWindows;

  constructor(data?: PartialMessage<PercentageDecisionPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.PercentageDecisionPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "percentage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "windows", kind: "message", T: DecisionPolicyWindows },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PercentageDecisionPolicy {
    return new PercentageDecisionPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PercentageDecisionPolicy {
    return new PercentageDecisionPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PercentageDecisionPolicy {
    return new PercentageDecisionPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: PercentageDecisionPolicy | PlainMessage<PercentageDecisionPolicy> | undefined, b: PercentageDecisionPolicy | PlainMessage<PercentageDecisionPolicy> | undefined): boolean {
    return proto3.util.equals(PercentageDecisionPolicy, a, b);
  }
}

/**
 * DecisionPolicyWindows defines the different windows for voting and execution.
 *
 * @generated from message cosmos.group.v1.DecisionPolicyWindows
 */
export class DecisionPolicyWindows extends Message<DecisionPolicyWindows> {
  /**
   * voting_period is the duration from submission of a proposal to the end of voting period
   * Within this times votes can be submitted with MsgVote.
   *
   * @generated from field: google.protobuf.Duration voting_period = 1;
   */
  votingPeriod?: Duration;

  /**
   * min_execution_period is the minimum duration after the proposal submission
   * where members can start sending MsgExec. This means that the window for
   * sending a MsgExec transaction is:
   * `[ submission + min_execution_period ; submission + voting_period + max_execution_period]`
   * where max_execution_period is a app-specific config, defined in the keeper.
   * If not set, min_execution_period will default to 0.
   *
   * Please make sure to set a `min_execution_period` that is smaller than
   * `voting_period + max_execution_period`, or else the above execution window
   * is empty, meaning that all proposals created with this decision policy
   * won't be able to be executed.
   *
   * @generated from field: google.protobuf.Duration min_execution_period = 2;
   */
  minExecutionPeriod?: Duration;

  constructor(data?: PartialMessage<DecisionPolicyWindows>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.DecisionPolicyWindows";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "voting_period", kind: "message", T: Duration },
    { no: 2, name: "min_execution_period", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DecisionPolicyWindows {
    return new DecisionPolicyWindows().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DecisionPolicyWindows {
    return new DecisionPolicyWindows().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DecisionPolicyWindows {
    return new DecisionPolicyWindows().fromJsonString(jsonString, options);
  }

  static equals(a: DecisionPolicyWindows | PlainMessage<DecisionPolicyWindows> | undefined, b: DecisionPolicyWindows | PlainMessage<DecisionPolicyWindows> | undefined): boolean {
    return proto3.util.equals(DecisionPolicyWindows, a, b);
  }
}

/**
 * GroupInfo represents the high-level on-chain information for a group.
 *
 * @generated from message cosmos.group.v1.GroupInfo
 */
export class GroupInfo extends Message<GroupInfo> {
  /**
   * id is the unique ID of the group.
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * admin is the account address of the group's admin.
   *
   * @generated from field: string admin = 2;
   */
  admin = "";

  /**
   * metadata is any arbitrary metadata to attached to the group.
   *
   * @generated from field: string metadata = 3;
   */
  metadata = "";

  /**
   * version is used to track changes to a group's membership structure that
   * would break existing proposals. Whenever any members weight is changed,
   * or any member is added or removed this version is incremented and will
   * cause proposals based on older versions of this group to fail
   *
   * @generated from field: uint64 version = 4;
   */
  version = protoInt64.zero;

  /**
   * total_weight is the sum of the group members' weights.
   *
   * @generated from field: string total_weight = 5;
   */
  totalWeight = "";

  /**
   * created_at is a timestamp specifying when a group was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;

  constructor(data?: PartialMessage<GroupInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.GroupInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "total_weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "created_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupInfo {
    return new GroupInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupInfo {
    return new GroupInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupInfo {
    return new GroupInfo().fromJsonString(jsonString, options);
  }

  static equals(a: GroupInfo | PlainMessage<GroupInfo> | undefined, b: GroupInfo | PlainMessage<GroupInfo> | undefined): boolean {
    return proto3.util.equals(GroupInfo, a, b);
  }
}

/**
 * GroupMember represents the relationship between a group and a member.
 *
 * @generated from message cosmos.group.v1.GroupMember
 */
export class GroupMember extends Message<GroupMember> {
  /**
   * group_id is the unique ID of the group.
   *
   * @generated from field: uint64 group_id = 1;
   */
  groupId = protoInt64.zero;

  /**
   * member is the member data.
   *
   * @generated from field: cosmos.group.v1.Member member = 2;
   */
  member?: Member;

  constructor(data?: PartialMessage<GroupMember>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.GroupMember";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "group_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "member", kind: "message", T: Member },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupMember {
    return new GroupMember().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupMember {
    return new GroupMember().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupMember {
    return new GroupMember().fromJsonString(jsonString, options);
  }

  static equals(a: GroupMember | PlainMessage<GroupMember> | undefined, b: GroupMember | PlainMessage<GroupMember> | undefined): boolean {
    return proto3.util.equals(GroupMember, a, b);
  }
}

/**
 * GroupPolicyInfo represents the high-level on-chain information for a group policy.
 *
 * @generated from message cosmos.group.v1.GroupPolicyInfo
 */
export class GroupPolicyInfo extends Message<GroupPolicyInfo> {
  /**
   * address is the account address of group policy.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * group_id is the unique ID of the group.
   *
   * @generated from field: uint64 group_id = 2;
   */
  groupId = protoInt64.zero;

  /**
   * admin is the account address of the group admin.
   *
   * @generated from field: string admin = 3;
   */
  admin = "";

  /**
   * metadata is any arbitrary metadata to attached to the group policy.
   *
   * @generated from field: string metadata = 4;
   */
  metadata = "";

  /**
   * version is used to track changes to a group's GroupPolicyInfo structure that
   * would create a different result on a running proposal.
   *
   * @generated from field: uint64 version = 5;
   */
  version = protoInt64.zero;

  /**
   * decision_policy specifies the group policy's decision policy.
   *
   * @generated from field: google.protobuf.Any decision_policy = 6;
   */
  decisionPolicy?: Any;

  /**
   * created_at is a timestamp specifying when a group policy was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  constructor(data?: PartialMessage<GroupPolicyInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.GroupPolicyInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "group_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "decision_policy", kind: "message", T: Any },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupPolicyInfo {
    return new GroupPolicyInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupPolicyInfo {
    return new GroupPolicyInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupPolicyInfo {
    return new GroupPolicyInfo().fromJsonString(jsonString, options);
  }

  static equals(a: GroupPolicyInfo | PlainMessage<GroupPolicyInfo> | undefined, b: GroupPolicyInfo | PlainMessage<GroupPolicyInfo> | undefined): boolean {
    return proto3.util.equals(GroupPolicyInfo, a, b);
  }
}

/**
 * Proposal defines a group proposal. Any member of a group can submit a proposal
 * for a group policy to decide upon.
 * A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
 * passes as well as some optional metadata associated with the proposal.
 *
 * @generated from message cosmos.group.v1.Proposal
 */
export class Proposal extends Message<Proposal> {
  /**
   * id is the unique id of the proposal.
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * address is the account address of group policy.
   *
   * @generated from field: string address = 2;
   */
  address = "";

  /**
   * metadata is any arbitrary metadata to attached to the proposal.
   *
   * @generated from field: string metadata = 3;
   */
  metadata = "";

  /**
   * proposers are the account addresses of the proposers.
   *
   * @generated from field: repeated string proposers = 4;
   */
  proposers: string[] = [];

  /**
   * submit_time is a timestamp specifying when a proposal was submitted.
   *
   * @generated from field: google.protobuf.Timestamp submit_time = 5;
   */
  submitTime?: Timestamp;

  /**
   * group_version tracks the version of the group that this proposal corresponds to.
   * When group membership is changed, existing proposals from previous group versions will become invalid.
   *
   * @generated from field: uint64 group_version = 6;
   */
  groupVersion = protoInt64.zero;

  /**
   * group_policy_version tracks the version of the group policy that this proposal corresponds to.
   * When a decision policy is changed, existing proposals from previous policy versions will become invalid.
   *
   * @generated from field: uint64 group_policy_version = 7;
   */
  groupPolicyVersion = protoInt64.zero;

  /**
   * status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
   *
   * @generated from field: cosmos.group.v1.ProposalStatus status = 8;
   */
  status = ProposalStatus.UNSPECIFIED;

  /**
   * result is the final result based on the votes and election rule. Initial value is unfinalized.
   * The result is persisted so that clients can always rely on this state and not have to replicate the logic.
   *
   * @generated from field: cosmos.group.v1.ProposalResult result = 9;
   */
  result = ProposalResult.UNSPECIFIED;

  /**
   * final_tally_result contains the sums of all weighted votes for this
   * proposal for each vote option, after tallying. When querying a proposal
   * via gRPC, this field is not populated until the proposal's voting period
   * has ended.
   *
   * @generated from field: cosmos.group.v1.TallyResult final_tally_result = 10;
   */
  finalTallyResult?: TallyResult;

  /**
   * voting_period_end is the timestamp before which voting must be done.
   * Unless a successfull MsgExec is called before (to execute a proposal whose
   * tally is successful before the voting period ends), tallying will be done
   * at this point, and the `final_tally_result`, as well
   * as `status` and `result` fields will be accordingly updated.
   *
   * @generated from field: google.protobuf.Timestamp voting_period_end = 11;
   */
  votingPeriodEnd?: Timestamp;

  /**
   * executor_result is the final result based on the votes and election rule. Initial value is NotRun.
   *
   * @generated from field: cosmos.group.v1.ProposalExecutorResult executor_result = 12;
   */
  executorResult = ProposalExecutorResult.UNSPECIFIED;

  /**
   * messages is a list of Msgs that will be executed if the proposal passes.
   *
   * @generated from field: repeated google.protobuf.Any messages = 13;
   */
  messages: Any[] = [];

  constructor(data?: PartialMessage<Proposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.Proposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "proposers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "submit_time", kind: "message", T: Timestamp },
    { no: 6, name: "group_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "group_policy_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "status", kind: "enum", T: proto3.getEnumType(ProposalStatus) },
    { no: 9, name: "result", kind: "enum", T: proto3.getEnumType(ProposalResult) },
    { no: 10, name: "final_tally_result", kind: "message", T: TallyResult },
    { no: 11, name: "voting_period_end", kind: "message", T: Timestamp },
    { no: 12, name: "executor_result", kind: "enum", T: proto3.getEnumType(ProposalExecutorResult) },
    { no: 13, name: "messages", kind: "message", T: Any, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposal {
    return new Proposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposal {
    return new Proposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposal {
    return new Proposal().fromJsonString(jsonString, options);
  }

  static equals(a: Proposal | PlainMessage<Proposal> | undefined, b: Proposal | PlainMessage<Proposal> | undefined): boolean {
    return proto3.util.equals(Proposal, a, b);
  }
}

/**
 * TallyResult represents the sum of weighted votes for each vote option.
 *
 * @generated from message cosmos.group.v1.TallyResult
 */
export class TallyResult extends Message<TallyResult> {
  /**
   * yes_count is the weighted sum of yes votes.
   *
   * @generated from field: string yes_count = 1;
   */
  yesCount = "";

  /**
   * abstain_count is the weighted sum of abstainers.
   *
   * @generated from field: string abstain_count = 2;
   */
  abstainCount = "";

  /**
   * no is the weighted sum of no votes.
   *
   * @generated from field: string no_count = 3;
   */
  noCount = "";

  /**
   * no_with_veto_count is the weighted sum of veto.
   *
   * @generated from field: string no_with_veto_count = 4;
   */
  noWithVetoCount = "";

  constructor(data?: PartialMessage<TallyResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.TallyResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "yes_count", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "abstain_count", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "no_count", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "no_with_veto_count", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TallyResult {
    return new TallyResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TallyResult {
    return new TallyResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TallyResult {
    return new TallyResult().fromJsonString(jsonString, options);
  }

  static equals(a: TallyResult | PlainMessage<TallyResult> | undefined, b: TallyResult | PlainMessage<TallyResult> | undefined): boolean {
    return proto3.util.equals(TallyResult, a, b);
  }
}

/**
 * Vote represents a vote for a proposal.
 *
 * @generated from message cosmos.group.v1.Vote
 */
export class Vote extends Message<Vote> {
  /**
   * proposal is the unique ID of the proposal.
   *
   * @generated from field: uint64 proposal_id = 1;
   */
  proposalId = protoInt64.zero;

  /**
   * voter is the account address of the voter.
   *
   * @generated from field: string voter = 2;
   */
  voter = "";

  /**
   * option is the voter's choice on the proposal.
   *
   * @generated from field: cosmos.group.v1.VoteOption option = 3;
   */
  option = VoteOption.UNSPECIFIED;

  /**
   * metadata is any arbitrary metadata to attached to the vote.
   *
   * @generated from field: string metadata = 4;
   */
  metadata = "";

  /**
   * submit_time is the timestamp when the vote was submitted.
   *
   * @generated from field: google.protobuf.Timestamp submit_time = 5;
   */
  submitTime?: Timestamp;

  constructor(data?: PartialMessage<Vote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.group.v1.Vote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "voter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "option", kind: "enum", T: proto3.getEnumType(VoteOption) },
    { no: 4, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "submit_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vote {
    return new Vote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vote {
    return new Vote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vote {
    return new Vote().fromJsonString(jsonString, options);
  }

  static equals(a: Vote | PlainMessage<Vote> | undefined, b: Vote | PlainMessage<Vote> | undefined): boolean {
    return proto3.util.equals(Vote, a, b);
  }
}

