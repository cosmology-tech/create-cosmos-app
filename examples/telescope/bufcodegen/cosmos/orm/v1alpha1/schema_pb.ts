// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file cosmos/orm/v1alpha1/schema.proto (package cosmos.orm.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * StorageType
 *
 * @generated from enum cosmos.orm.v1alpha1.StorageType
 */
export enum StorageType {
  /**
   * STORAGE_TYPE_DEFAULT_UNSPECIFIED indicates the persistent
   * KV-storage where primary key entries are stored in merkle-tree
   * backed commitment storage and indexes and seqs are stored in
   * fast index storage. Note that the Cosmos SDK before store/v2alpha1
   * does not support this.
   *
   * @generated from enum value: STORAGE_TYPE_DEFAULT_UNSPECIFIED = 0;
   */
  DEFAULT_UNSPECIFIED = 0,

  /**
   * STORAGE_TYPE_MEMORY indicates in-memory storage that will be
   * reloaded every time an app restarts. Tables with this type of storage
   * will by default be ignored when importing and exporting a module's
   * state from JSON.
   *
   * @generated from enum value: STORAGE_TYPE_MEMORY = 1;
   */
  MEMORY = 1,

  /**
   * STORAGE_TYPE_TRANSIENT indicates transient storage that is reset
   * at the end of every block. Tables with this type of storage
   * will by default be ignored when importing and exporting a module's
   * state from JSON.
   *
   * @generated from enum value: STORAGE_TYPE_TRANSIENT = 2;
   */
  TRANSIENT = 2,

  /**
   * STORAGE_TYPE_INDEX indicates persistent storage which is not backed
   * by a merkle-tree and won't affect the app hash. Note that the Cosmos SDK
   * before store/v2alpha1 does not support this.
   *
   * @generated from enum value: STORAGE_TYPE_INDEX = 3;
   */
  INDEX = 3,

  /**
   * STORAGE_TYPE_INDEX indicates persistent storage which is backed by
   * a merkle-tree. With this type of storage, both primary and index keys
   * will affect the app hash and this is generally less efficient
   * than using STORAGE_TYPE_DEFAULT_UNSPECIFIED which separates index
   * keys into index storage. Note that modules built with the
   * Cosmos SDK before store/v2alpha1 must specify STORAGE_TYPE_COMMITMENT
   * instead of STORAGE_TYPE_DEFAULT_UNSPECIFIED or STORAGE_TYPE_INDEX
   * because this is the only type of persistent storage available.
   *
   * @generated from enum value: STORAGE_TYPE_COMMITMENT = 4;
   */
  COMMITMENT = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(StorageType)
proto3.util.setEnumType(StorageType, "cosmos.orm.v1alpha1.StorageType", [
  { no: 0, name: "STORAGE_TYPE_DEFAULT_UNSPECIFIED" },
  { no: 1, name: "STORAGE_TYPE_MEMORY" },
  { no: 2, name: "STORAGE_TYPE_TRANSIENT" },
  { no: 3, name: "STORAGE_TYPE_INDEX" },
  { no: 4, name: "STORAGE_TYPE_COMMITMENT" },
]);

/**
 * ModuleSchemaDescriptor describe's a module's ORM schema.
 *
 * @generated from message cosmos.orm.v1alpha1.ModuleSchemaDescriptor
 */
export class ModuleSchemaDescriptor extends Message<ModuleSchemaDescriptor> {
  /**
   * @generated from field: repeated cosmos.orm.v1alpha1.ModuleSchemaDescriptor.FileEntry schema_file = 1;
   */
  schemaFile: ModuleSchemaDescriptor_FileEntry[] = [];

  /**
   * prefix is an optional prefix that precedes all keys in this module's
   * store.
   *
   * @generated from field: bytes prefix = 2;
   */
  prefix = new Uint8Array(0);

  constructor(data?: PartialMessage<ModuleSchemaDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.orm.v1alpha1.ModuleSchemaDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema_file", kind: "message", T: ModuleSchemaDescriptor_FileEntry, repeated: true },
    { no: 2, name: "prefix", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleSchemaDescriptor {
    return new ModuleSchemaDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleSchemaDescriptor {
    return new ModuleSchemaDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleSchemaDescriptor {
    return new ModuleSchemaDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleSchemaDescriptor | PlainMessage<ModuleSchemaDescriptor> | undefined, b: ModuleSchemaDescriptor | PlainMessage<ModuleSchemaDescriptor> | undefined): boolean {
    return proto3.util.equals(ModuleSchemaDescriptor, a, b);
  }
}

/**
 * FileEntry describes an ORM file used in a module.
 *
 * @generated from message cosmos.orm.v1alpha1.ModuleSchemaDescriptor.FileEntry
 */
export class ModuleSchemaDescriptor_FileEntry extends Message<ModuleSchemaDescriptor_FileEntry> {
  /**
   * id is a prefix that will be varint encoded and prepended to all the
   * table keys specified in the file's tables.
   *
   * @generated from field: uint32 id = 1;
   */
  id = 0;

  /**
   * proto_file_name is the name of a file .proto in that contains
   * table definitions. The .proto file must be in a package that the
   * module has referenced using cosmos.app.v1.ModuleDescriptor.use_package.
   *
   * @generated from field: string proto_file_name = 2;
   */
  protoFileName = "";

  /**
   * storage_type optionally indicates the type of storage this file's
   * tables should used. If it is left unspecified, the default KV-storage
   * of the app will be used.
   *
   * @generated from field: cosmos.orm.v1alpha1.StorageType storage_type = 3;
   */
  storageType = StorageType.DEFAULT_UNSPECIFIED;

  constructor(data?: PartialMessage<ModuleSchemaDescriptor_FileEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.orm.v1alpha1.ModuleSchemaDescriptor.FileEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "proto_file_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "storage_type", kind: "enum", T: proto3.getEnumType(StorageType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleSchemaDescriptor_FileEntry {
    return new ModuleSchemaDescriptor_FileEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleSchemaDescriptor_FileEntry {
    return new ModuleSchemaDescriptor_FileEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleSchemaDescriptor_FileEntry {
    return new ModuleSchemaDescriptor_FileEntry().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleSchemaDescriptor_FileEntry | PlainMessage<ModuleSchemaDescriptor_FileEntry> | undefined, b: ModuleSchemaDescriptor_FileEntry | PlainMessage<ModuleSchemaDescriptor_FileEntry> | undefined): boolean {
    return proto3.util.equals(ModuleSchemaDescriptor_FileEntry, a, b);
  }
}

