import { Timestamp, TimestampAmino, TimestampSDKType } from "../../../protobuf/timestamp";
import { ConfigChange, ConfigChangeAmino, ConfigChangeSDKType } from "../../config_change";
import * as _m0 from "protobufjs/minimal";
import { isSet, DeepPartial, toTimestamp, fromTimestamp, bytesFromBase64, base64FromBytes, isObject } from "../../../../helpers";
export const protobufPackage = "google.api.servicemanagement.v1";
/** Code describes the status of the operation (or one of its steps). */
export enum OperationMetadata_Status {
  /** STATUS_UNSPECIFIED - Unspecifed code. */
  STATUS_UNSPECIFIED = 0,
  /** DONE - The operation or step has completed without errors. */
  DONE = 1,
  /** NOT_STARTED - The operation or step has not started yet. */
  NOT_STARTED = 2,
  /** IN_PROGRESS - The operation or step is in progress. */
  IN_PROGRESS = 3,
  /**
   * FAILED - The operation or step has completed with errors. If the operation is
   * rollbackable, the rollback completed with errors too.
   */
  FAILED = 4,
  /** CANCELLED - The operation or step has completed with cancellation. */
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}
export const OperationMetadata_StatusSDKType = OperationMetadata_Status;
export const OperationMetadata_StatusAmino = OperationMetadata_Status;
export function operationMetadata_StatusFromJSON(object: any): OperationMetadata_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return OperationMetadata_Status.STATUS_UNSPECIFIED;
    case 1:
    case "DONE":
      return OperationMetadata_Status.DONE;
    case 2:
    case "NOT_STARTED":
      return OperationMetadata_Status.NOT_STARTED;
    case 3:
    case "IN_PROGRESS":
      return OperationMetadata_Status.IN_PROGRESS;
    case 4:
    case "FAILED":
      return OperationMetadata_Status.FAILED;
    case 5:
    case "CANCELLED":
      return OperationMetadata_Status.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationMetadata_Status.UNRECOGNIZED;
  }
}
export function operationMetadata_StatusToJSON(object: OperationMetadata_Status): string {
  switch (object) {
    case OperationMetadata_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case OperationMetadata_Status.DONE:
      return "DONE";
    case OperationMetadata_Status.NOT_STARTED:
      return "NOT_STARTED";
    case OperationMetadata_Status.IN_PROGRESS:
      return "IN_PROGRESS";
    case OperationMetadata_Status.FAILED:
      return "FAILED";
    case OperationMetadata_Status.CANCELLED:
      return "CANCELLED";
    case OperationMetadata_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
/** The kind of diagnostic information possible. */
export enum Diagnostic_Kind {
  /** WARNING - Warnings and errors */
  WARNING = 0,
  /** ERROR - Only errors */
  ERROR = 1,
  UNRECOGNIZED = -1,
}
export const Diagnostic_KindSDKType = Diagnostic_Kind;
export const Diagnostic_KindAmino = Diagnostic_Kind;
export function diagnostic_KindFromJSON(object: any): Diagnostic_Kind {
  switch (object) {
    case 0:
    case "WARNING":
      return Diagnostic_Kind.WARNING;
    case 1:
    case "ERROR":
      return Diagnostic_Kind.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Diagnostic_Kind.UNRECOGNIZED;
  }
}
export function diagnostic_KindToJSON(object: Diagnostic_Kind): string {
  switch (object) {
    case Diagnostic_Kind.WARNING:
      return "WARNING";
    case Diagnostic_Kind.ERROR:
      return "ERROR";
    case Diagnostic_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
export enum ConfigFile_FileType {
  /** FILE_TYPE_UNSPECIFIED - Unknown file type. */
  FILE_TYPE_UNSPECIFIED = 0,
  /** SERVICE_CONFIG_YAML - YAML-specification of service. */
  SERVICE_CONFIG_YAML = 1,
  /** OPEN_API_JSON - OpenAPI specification, serialized in JSON. */
  OPEN_API_JSON = 2,
  /** OPEN_API_YAML - OpenAPI specification, serialized in YAML. */
  OPEN_API_YAML = 3,
  /**
   * FILE_DESCRIPTOR_SET_PROTO - FileDescriptorSet, generated by protoc.
   * 
   * To generate, use protoc with imports and source info included.
   * For an example test.proto file, the following command would put the value
   * in a new file named out.pb.
   * 
   * $protoc --include_imports --include_source_info test.proto -o out.pb
   */
  FILE_DESCRIPTOR_SET_PROTO = 4,
  /**
   * PROTO_FILE - Uncompiled Proto file. Used for storage and display purposes only,
   * currently server-side compilation is not supported. Should match the
   * inputs to 'protoc' command used to generated FILE_DESCRIPTOR_SET_PROTO. A
   * file of this type can only be included if at least one file of type
   * FILE_DESCRIPTOR_SET_PROTO is included.
   */
  PROTO_FILE = 6,
  UNRECOGNIZED = -1,
}
export const ConfigFile_FileTypeSDKType = ConfigFile_FileType;
export const ConfigFile_FileTypeAmino = ConfigFile_FileType;
export function configFile_FileTypeFromJSON(object: any): ConfigFile_FileType {
  switch (object) {
    case 0:
    case "FILE_TYPE_UNSPECIFIED":
      return ConfigFile_FileType.FILE_TYPE_UNSPECIFIED;
    case 1:
    case "SERVICE_CONFIG_YAML":
      return ConfigFile_FileType.SERVICE_CONFIG_YAML;
    case 2:
    case "OPEN_API_JSON":
      return ConfigFile_FileType.OPEN_API_JSON;
    case 3:
    case "OPEN_API_YAML":
      return ConfigFile_FileType.OPEN_API_YAML;
    case 4:
    case "FILE_DESCRIPTOR_SET_PROTO":
      return ConfigFile_FileType.FILE_DESCRIPTOR_SET_PROTO;
    case 6:
    case "PROTO_FILE":
      return ConfigFile_FileType.PROTO_FILE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConfigFile_FileType.UNRECOGNIZED;
  }
}
export function configFile_FileTypeToJSON(object: ConfigFile_FileType): string {
  switch (object) {
    case ConfigFile_FileType.FILE_TYPE_UNSPECIFIED:
      return "FILE_TYPE_UNSPECIFIED";
    case ConfigFile_FileType.SERVICE_CONFIG_YAML:
      return "SERVICE_CONFIG_YAML";
    case ConfigFile_FileType.OPEN_API_JSON:
      return "OPEN_API_JSON";
    case ConfigFile_FileType.OPEN_API_YAML:
      return "OPEN_API_YAML";
    case ConfigFile_FileType.FILE_DESCRIPTOR_SET_PROTO:
      return "FILE_DESCRIPTOR_SET_PROTO";
    case ConfigFile_FileType.PROTO_FILE:
      return "PROTO_FILE";
    case ConfigFile_FileType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
/** Status of a Rollout. */
export enum Rollout_RolloutStatus {
  /** ROLLOUT_STATUS_UNSPECIFIED - No status specified. */
  ROLLOUT_STATUS_UNSPECIFIED = 0,
  /** IN_PROGRESS - The Rollout is in progress. */
  IN_PROGRESS = 1,
  /** SUCCESS - The Rollout has completed successfully. */
  SUCCESS = 2,
  /**
   * CANCELLED - The Rollout has been cancelled. This can happen if you have overlapping
   * Rollout pushes, and the previous ones will be cancelled.
   */
  CANCELLED = 3,
  /** FAILED - The Rollout has failed and the rollback attempt has failed too. */
  FAILED = 4,
  /** PENDING - The Rollout has not started yet and is pending for execution. */
  PENDING = 5,
  /**
   * FAILED_ROLLED_BACK - The Rollout has failed and rolled back to the previous successful
   * Rollout.
   */
  FAILED_ROLLED_BACK = 6,
  UNRECOGNIZED = -1,
}
export const Rollout_RolloutStatusSDKType = Rollout_RolloutStatus;
export const Rollout_RolloutStatusAmino = Rollout_RolloutStatus;
export function rollout_RolloutStatusFromJSON(object: any): Rollout_RolloutStatus {
  switch (object) {
    case 0:
    case "ROLLOUT_STATUS_UNSPECIFIED":
      return Rollout_RolloutStatus.ROLLOUT_STATUS_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return Rollout_RolloutStatus.IN_PROGRESS;
    case 2:
    case "SUCCESS":
      return Rollout_RolloutStatus.SUCCESS;
    case 3:
    case "CANCELLED":
      return Rollout_RolloutStatus.CANCELLED;
    case 4:
    case "FAILED":
      return Rollout_RolloutStatus.FAILED;
    case 5:
    case "PENDING":
      return Rollout_RolloutStatus.PENDING;
    case 6:
    case "FAILED_ROLLED_BACK":
      return Rollout_RolloutStatus.FAILED_ROLLED_BACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rollout_RolloutStatus.UNRECOGNIZED;
  }
}
export function rollout_RolloutStatusToJSON(object: Rollout_RolloutStatus): string {
  switch (object) {
    case Rollout_RolloutStatus.ROLLOUT_STATUS_UNSPECIFIED:
      return "ROLLOUT_STATUS_UNSPECIFIED";
    case Rollout_RolloutStatus.IN_PROGRESS:
      return "IN_PROGRESS";
    case Rollout_RolloutStatus.SUCCESS:
      return "SUCCESS";
    case Rollout_RolloutStatus.CANCELLED:
      return "CANCELLED";
    case Rollout_RolloutStatus.FAILED:
      return "FAILED";
    case Rollout_RolloutStatus.PENDING:
      return "PENDING";
    case Rollout_RolloutStatus.FAILED_ROLLED_BACK:
      return "FAILED_ROLLED_BACK";
    case Rollout_RolloutStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
/**
 * The full representation of a Service that is managed by
 * Google Service Management.
 */
export interface ManagedService {
  /**
   * The name of the service. See the [overview](/service-management/overview)
   * for naming requirements.
   */
  serviceName: string;
  /** ID of the project that produces and owns this service. */
  producerProjectId: string;
}
export interface ManagedServiceProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.ManagedService";
  value: Uint8Array;
}
/**
 * The full representation of a Service that is managed by
 * Google Service Management.
 */
export interface ManagedServiceAmino {
  /**
   * The name of the service. See the [overview](/service-management/overview)
   * for naming requirements.
   */
  service_name: string;
  /** ID of the project that produces and owns this service. */
  producer_project_id: string;
}
export interface ManagedServiceAminoMsg {
  type: "/google.api.servicemanagement.v1.ManagedService";
  value: ManagedServiceAmino;
}
/**
 * The full representation of a Service that is managed by
 * Google Service Management.
 */
export interface ManagedServiceSDKType {
  service_name: string;
  producer_project_id: string;
}
/** The metadata associated with a long running operation resource. */
export interface OperationMetadata {
  /**
   * The full name of the resources that this operation is directly
   * associated with.
   */
  resourceNames: string[];
  /** Detailed status information for each step. The order is undetermined. */
  steps: OperationMetadata_Step[];
  /** Percentage of completion of this operation, ranging from 0 to 100. */
  progressPercentage: number;
  /** The start time of the operation. */
  startTime?: Date;
}
export interface OperationMetadataProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.OperationMetadata";
  value: Uint8Array;
}
/** The metadata associated with a long running operation resource. */
export interface OperationMetadataAmino {
  /**
   * The full name of the resources that this operation is directly
   * associated with.
   */
  resource_names: string[];
  /** Detailed status information for each step. The order is undetermined. */
  steps: OperationMetadata_StepAmino[];
  /** Percentage of completion of this operation, ranging from 0 to 100. */
  progress_percentage: number;
  /** The start time of the operation. */
  start_time?: Date;
}
export interface OperationMetadataAminoMsg {
  type: "/google.api.servicemanagement.v1.OperationMetadata";
  value: OperationMetadataAmino;
}
/** The metadata associated with a long running operation resource. */
export interface OperationMetadataSDKType {
  resource_names: string[];
  steps: OperationMetadata_StepSDKType[];
  progress_percentage: number;
  start_time?: Date;
}
/** Represents the status of one operation step. */
export interface OperationMetadata_Step {
  /** The short description of the step. */
  description: string;
  /** The status code. */
  status: OperationMetadata_Status;
}
export interface OperationMetadata_StepProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.Step";
  value: Uint8Array;
}
/** Represents the status of one operation step. */
export interface OperationMetadata_StepAmino {
  /** The short description of the step. */
  description: string;
  /** The status code. */
  status: OperationMetadata_Status;
}
export interface OperationMetadata_StepAminoMsg {
  type: "/google.api.servicemanagement.v1.Step";
  value: OperationMetadata_StepAmino;
}
/** Represents the status of one operation step. */
export interface OperationMetadata_StepSDKType {
  description: string;
  status: OperationMetadata_Status;
}
/** Represents a diagnostic message (error or warning) */
export interface Diagnostic {
  /** File name and line number of the error or warning. */
  location: string;
  /** The kind of diagnostic information provided. */
  kind: Diagnostic_Kind;
  /** Message describing the error or warning. */
  message: string;
}
export interface DiagnosticProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.Diagnostic";
  value: Uint8Array;
}
/** Represents a diagnostic message (error or warning) */
export interface DiagnosticAmino {
  /** File name and line number of the error or warning. */
  location: string;
  /** The kind of diagnostic information provided. */
  kind: Diagnostic_Kind;
  /** Message describing the error or warning. */
  message: string;
}
export interface DiagnosticAminoMsg {
  type: "/google.api.servicemanagement.v1.Diagnostic";
  value: DiagnosticAmino;
}
/** Represents a diagnostic message (error or warning) */
export interface DiagnosticSDKType {
  location: string;
  kind: Diagnostic_Kind;
  message: string;
}
/**
 * Represents a source file which is used to generate the service configuration
 * defined by `google.api.Service`.
 */
export interface ConfigSource {
  /**
   * A unique ID for a specific instance of this message, typically assigned
   * by the client for tracking purpose. If empty, the server may choose to
   * generate one instead.
   */
  id: string;
  /**
   * Set of source configuration files that are used to generate a service
   * configuration (`google.api.Service`).
   */
  files: ConfigFile[];
}
export interface ConfigSourceProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.ConfigSource";
  value: Uint8Array;
}
/**
 * Represents a source file which is used to generate the service configuration
 * defined by `google.api.Service`.
 */
export interface ConfigSourceAmino {
  /**
   * A unique ID for a specific instance of this message, typically assigned
   * by the client for tracking purpose. If empty, the server may choose to
   * generate one instead.
   */
  id: string;
  /**
   * Set of source configuration files that are used to generate a service
   * configuration (`google.api.Service`).
   */
  files: ConfigFileAmino[];
}
export interface ConfigSourceAminoMsg {
  type: "/google.api.servicemanagement.v1.ConfigSource";
  value: ConfigSourceAmino;
}
/**
 * Represents a source file which is used to generate the service configuration
 * defined by `google.api.Service`.
 */
export interface ConfigSourceSDKType {
  id: string;
  files: ConfigFileSDKType[];
}
/** Generic specification of a source configuration file */
export interface ConfigFile {
  /** The file name of the configuration file (full or relative path). */
  filePath: string;
  /** The bytes that constitute the file. */
  fileContents: Uint8Array;
  /** The type of configuration file this represents. */
  fileType: ConfigFile_FileType;
}
export interface ConfigFileProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.ConfigFile";
  value: Uint8Array;
}
/** Generic specification of a source configuration file */
export interface ConfigFileAmino {
  /** The file name of the configuration file (full or relative path). */
  file_path: string;
  /** The bytes that constitute the file. */
  file_contents: Uint8Array;
  /** The type of configuration file this represents. */
  file_type: ConfigFile_FileType;
}
export interface ConfigFileAminoMsg {
  type: "/google.api.servicemanagement.v1.ConfigFile";
  value: ConfigFileAmino;
}
/** Generic specification of a source configuration file */
export interface ConfigFileSDKType {
  file_path: string;
  file_contents: Uint8Array;
  file_type: ConfigFile_FileType;
}
/** Represents a service configuration with its name and id. */
export interface ConfigRef {
  /**
   * Resource name of a service config. It must have the following
   * format: "services/{service name}/configs/{config id}".
   */
  name: string;
}
export interface ConfigRefProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.ConfigRef";
  value: Uint8Array;
}
/** Represents a service configuration with its name and id. */
export interface ConfigRefAmino {
  /**
   * Resource name of a service config. It must have the following
   * format: "services/{service name}/configs/{config id}".
   */
  name: string;
}
export interface ConfigRefAminoMsg {
  type: "/google.api.servicemanagement.v1.ConfigRef";
  value: ConfigRefAmino;
}
/** Represents a service configuration with its name and id. */
export interface ConfigRefSDKType {
  name: string;
}
/**
 * Change report associated with a particular service configuration.
 * 
 * It contains a list of ConfigChanges based on the comparison between
 * two service configurations.
 */
export interface ChangeReport {
  /**
   * List of changes between two service configurations.
   * The changes will be alphabetically sorted based on the identifier
   * of each change.
   * A ConfigChange identifier is a dot separated path to the configuration.
   * Example: visibility.rules[selector='LibraryService.CreateBook'].restriction
   */
  configChanges: ConfigChange[];
}
export interface ChangeReportProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.ChangeReport";
  value: Uint8Array;
}
/**
 * Change report associated with a particular service configuration.
 * 
 * It contains a list of ConfigChanges based on the comparison between
 * two service configurations.
 */
export interface ChangeReportAmino {
  /**
   * List of changes between two service configurations.
   * The changes will be alphabetically sorted based on the identifier
   * of each change.
   * A ConfigChange identifier is a dot separated path to the configuration.
   * Example: visibility.rules[selector='LibraryService.CreateBook'].restriction
   */
  config_changes: ConfigChangeAmino[];
}
export interface ChangeReportAminoMsg {
  type: "/google.api.servicemanagement.v1.ChangeReport";
  value: ChangeReportAmino;
}
/**
 * Change report associated with a particular service configuration.
 * 
 * It contains a list of ConfigChanges based on the comparison between
 * two service configurations.
 */
export interface ChangeReportSDKType {
  config_changes: ConfigChangeSDKType[];
}
/**
 * A rollout resource that defines how service configuration versions are pushed
 * to control plane systems. Typically, you create a new version of the
 * service config, and then create a Rollout to push the service config.
 */
export interface Rollout {
  /**
   * Optional. Unique identifier of this Rollout. Must be no longer than 63 characters
   * and only lower case letters, digits, '.', '_' and '-' are allowed.
   * 
   * If not specified by client, the server will generate one. The generated id
   * will have the form of <date><revision number>, where "date" is the create
   * date in ISO 8601 format.  "revision number" is a monotonically increasing
   * positive number that is reset every day for each service.
   * An example of the generated rollout_id is '2016-02-16r1'
   */
  rolloutId: string;
  /** Creation time of the rollout. Readonly. */
  createTime?: Date;
  /** The user who created the Rollout. Readonly. */
  createdBy: string;
  /**
   * The status of this rollout. Readonly. In case of a failed rollout,
   * the system will automatically rollback to the current Rollout
   * version. Readonly.
   */
  status: Rollout_RolloutStatus;
  /**
   * Google Service Control selects service configurations based on
   * traffic percentage.
   */
  trafficPercentStrategy?: Rollout_TrafficPercentStrategy;
  /**
   * The strategy associated with a rollout to delete a `ManagedService`.
   * Readonly.
   */
  deleteServiceStrategy?: Rollout_DeleteServiceStrategy;
  /** The name of the service associated with this Rollout. */
  serviceName: string;
}
export interface RolloutProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.Rollout";
  value: Uint8Array;
}
/**
 * A rollout resource that defines how service configuration versions are pushed
 * to control plane systems. Typically, you create a new version of the
 * service config, and then create a Rollout to push the service config.
 */
export interface RolloutAmino {
  /**
   * Optional. Unique identifier of this Rollout. Must be no longer than 63 characters
   * and only lower case letters, digits, '.', '_' and '-' are allowed.
   * 
   * If not specified by client, the server will generate one. The generated id
   * will have the form of <date><revision number>, where "date" is the create
   * date in ISO 8601 format.  "revision number" is a monotonically increasing
   * positive number that is reset every day for each service.
   * An example of the generated rollout_id is '2016-02-16r1'
   */
  rollout_id: string;
  /** Creation time of the rollout. Readonly. */
  create_time?: Date;
  /** The user who created the Rollout. Readonly. */
  created_by: string;
  /**
   * The status of this rollout. Readonly. In case of a failed rollout,
   * the system will automatically rollback to the current Rollout
   * version. Readonly.
   */
  status: Rollout_RolloutStatus;
  /**
   * Google Service Control selects service configurations based on
   * traffic percentage.
   */
  traffic_percent_strategy?: Rollout_TrafficPercentStrategyAmino;
  /**
   * The strategy associated with a rollout to delete a `ManagedService`.
   * Readonly.
   */
  delete_service_strategy?: Rollout_DeleteServiceStrategyAmino;
  /** The name of the service associated with this Rollout. */
  service_name: string;
}
export interface RolloutAminoMsg {
  type: "/google.api.servicemanagement.v1.Rollout";
  value: RolloutAmino;
}
/**
 * A rollout resource that defines how service configuration versions are pushed
 * to control plane systems. Typically, you create a new version of the
 * service config, and then create a Rollout to push the service config.
 */
export interface RolloutSDKType {
  rollout_id: string;
  create_time?: Date;
  created_by: string;
  status: Rollout_RolloutStatus;
  traffic_percent_strategy?: Rollout_TrafficPercentStrategySDKType;
  delete_service_strategy?: Rollout_DeleteServiceStrategySDKType;
  service_name: string;
}
export interface Rollout_TrafficPercentStrategy_PercentagesEntry {
  key: string;
  value: number;
}
export interface Rollout_TrafficPercentStrategy_PercentagesEntryProtoMsg {
  typeUrl: string;
  value: Uint8Array;
}
export interface Rollout_TrafficPercentStrategy_PercentagesEntryAmino {
  key: string;
  value: number;
}
export interface Rollout_TrafficPercentStrategy_PercentagesEntryAminoMsg {
  type: string;
  value: Rollout_TrafficPercentStrategy_PercentagesEntryAmino;
}
export interface Rollout_TrafficPercentStrategy_PercentagesEntrySDKType {
  key: string;
  value: number;
}
/**
 * Strategy that specifies how clients of Google Service Controller want to
 * send traffic to use different config versions. This is generally
 * used by API proxy to split traffic based on your configured percentage for
 * each config version.
 * 
 * One example of how to gradually rollout a new service configuration using
 * this
 * strategy:
 * Day 1
 * 
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160206"
 *       traffic_percent_strategy {
 *         percentages: {
 *           "example.googleapis.com/20160201": 70.00
 *           "example.googleapis.com/20160206": 30.00
 *         }
 *       }
 *     }
 * 
 * Day 2
 * 
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160207"
 *       traffic_percent_strategy: {
 *         percentages: {
 *           "example.googleapis.com/20160206": 100.00
 *         }
 *       }
 *     }
 */
export interface Rollout_TrafficPercentStrategy {
  /**
   * Maps service configuration IDs to their corresponding traffic percentage.
   * Key is the service configuration ID, Value is the traffic percentage
   * which must be greater than 0.0 and the sum must equal to 100.0.
   */
  percentages: {
    [key: string]: number;
  };
}
export interface Rollout_TrafficPercentStrategyProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.TrafficPercentStrategy";
  value: Uint8Array;
}
/**
 * Strategy that specifies how clients of Google Service Controller want to
 * send traffic to use different config versions. This is generally
 * used by API proxy to split traffic based on your configured percentage for
 * each config version.
 * 
 * One example of how to gradually rollout a new service configuration using
 * this
 * strategy:
 * Day 1
 * 
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160206"
 *       traffic_percent_strategy {
 *         percentages: {
 *           "example.googleapis.com/20160201": 70.00
 *           "example.googleapis.com/20160206": 30.00
 *         }
 *       }
 *     }
 * 
 * Day 2
 * 
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160207"
 *       traffic_percent_strategy: {
 *         percentages: {
 *           "example.googleapis.com/20160206": 100.00
 *         }
 *       }
 *     }
 */
export interface Rollout_TrafficPercentStrategyAmino {
  /**
   * Maps service configuration IDs to their corresponding traffic percentage.
   * Key is the service configuration ID, Value is the traffic percentage
   * which must be greater than 0.0 and the sum must equal to 100.0.
   */
  percentages: {
    [key: string]: number;
  };
}
export interface Rollout_TrafficPercentStrategyAminoMsg {
  type: "/google.api.servicemanagement.v1.TrafficPercentStrategy";
  value: Rollout_TrafficPercentStrategyAmino;
}
/**
 * Strategy that specifies how clients of Google Service Controller want to
 * send traffic to use different config versions. This is generally
 * used by API proxy to split traffic based on your configured percentage for
 * each config version.
 * 
 * One example of how to gradually rollout a new service configuration using
 * this
 * strategy:
 * Day 1
 * 
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160206"
 *       traffic_percent_strategy {
 *         percentages: {
 *           "example.googleapis.com/20160201": 70.00
 *           "example.googleapis.com/20160206": 30.00
 *         }
 *       }
 *     }
 * 
 * Day 2
 * 
 *     Rollout {
 *       id: "example.googleapis.com/rollout_20160207"
 *       traffic_percent_strategy: {
 *         percentages: {
 *           "example.googleapis.com/20160206": 100.00
 *         }
 *       }
 *     }
 */
export interface Rollout_TrafficPercentStrategySDKType {
  percentages: {
    [key: string]: number;
  };
}
/**
 * Strategy used to delete a service. This strategy is a placeholder only
 * used by the system generated rollout to delete a service.
 */
export interface Rollout_DeleteServiceStrategy {}
export interface Rollout_DeleteServiceStrategyProtoMsg {
  typeUrl: "/google.api.servicemanagement.v1.DeleteServiceStrategy";
  value: Uint8Array;
}
/**
 * Strategy used to delete a service. This strategy is a placeholder only
 * used by the system generated rollout to delete a service.
 */
export interface Rollout_DeleteServiceStrategyAmino {}
export interface Rollout_DeleteServiceStrategyAminoMsg {
  type: "/google.api.servicemanagement.v1.DeleteServiceStrategy";
  value: Rollout_DeleteServiceStrategyAmino;
}
/**
 * Strategy used to delete a service. This strategy is a placeholder only
 * used by the system generated rollout to delete a service.
 */
export interface Rollout_DeleteServiceStrategySDKType {}
function createBaseManagedService(): ManagedService {
  return {
    serviceName: "",
    producerProjectId: ""
  };
}
export const ManagedService = {
  typeUrl: "/google.api.servicemanagement.v1.ManagedService",
  encode(message: ManagedService, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceName !== "") {
      writer.uint32(18).string(message.serviceName);
    }
    if (message.producerProjectId !== "") {
      writer.uint32(26).string(message.producerProjectId);
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): ManagedService {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManagedService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.serviceName = reader.string();
          break;
        case 3:
          message.producerProjectId = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ManagedService {
    return {
      serviceName: isSet(object.serviceName) ? String(object.serviceName) : "",
      producerProjectId: isSet(object.producerProjectId) ? String(object.producerProjectId) : ""
    };
  },
  toJSON(message: ManagedService): unknown {
    const obj: any = {};
    message.serviceName !== undefined && (obj.serviceName = message.serviceName);
    message.producerProjectId !== undefined && (obj.producerProjectId = message.producerProjectId);
    return obj;
  },
  fromPartial(object: DeepPartial<ManagedService>): ManagedService {
    const message = createBaseManagedService();
    message.serviceName = object.serviceName ?? "";
    message.producerProjectId = object.producerProjectId ?? "";
    return message;
  },
  fromSDK(object: ManagedServiceSDKType): ManagedService {
    return {
      serviceName: object?.service_name,
      producerProjectId: object?.producer_project_id
    };
  },
  toSDK(message: ManagedService): ManagedServiceSDKType {
    const obj: any = {};
    obj.service_name = message.serviceName;
    obj.producer_project_id = message.producerProjectId;
    return obj;
  },
  fromAmino(object: ManagedServiceAmino): ManagedService {
    return {
      serviceName: object.service_name,
      producerProjectId: object.producer_project_id
    };
  },
  toAmino(message: ManagedService): ManagedServiceAmino {
    const obj: any = {};
    obj.service_name = message.serviceName;
    obj.producer_project_id = message.producerProjectId;
    return obj;
  },
  fromAminoMsg(object: ManagedServiceAminoMsg): ManagedService {
    return ManagedService.fromAmino(object.value);
  },
  fromProtoMsg(message: ManagedServiceProtoMsg): ManagedService {
    return ManagedService.decode(message.value);
  },
  toProto(message: ManagedService): Uint8Array {
    return ManagedService.encode(message).finish();
  },
  toProtoMsg(message: ManagedService): ManagedServiceProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.ManagedService",
      value: ManagedService.encode(message).finish()
    };
  }
};
function createBaseOperationMetadata(): OperationMetadata {
  return {
    resourceNames: [],
    steps: [],
    progressPercentage: 0,
    startTime: undefined
  };
}
export const OperationMetadata = {
  typeUrl: "/google.api.servicemanagement.v1.OperationMetadata",
  encode(message: OperationMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resourceNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.steps) {
      OperationMetadata_Step.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.progressPercentage !== 0) {
      writer.uint32(24).int32(message.progressPercentage);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.resourceNames.push(reader.string());
          break;
        case 2:
          message.steps.push(OperationMetadata_Step.decode(reader, reader.uint32()));
          break;
        case 3:
          message.progressPercentage = reader.int32();
          break;
        case 4:
          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): OperationMetadata {
    return {
      resourceNames: Array.isArray(object?.resourceNames) ? object.resourceNames.map((e: any) => String(e)) : [],
      steps: Array.isArray(object?.steps) ? object.steps.map((e: any) => OperationMetadata_Step.fromJSON(e)) : [],
      progressPercentage: isSet(object.progressPercentage) ? Number(object.progressPercentage) : 0,
      startTime: isSet(object.startTime) ? new Date(object.startTime) : undefined
    };
  },
  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.resourceNames) {
      obj.resourceNames = message.resourceNames.map(e => e);
    } else {
      obj.resourceNames = [];
    }
    if (message.steps) {
      obj.steps = message.steps.map(e => e ? OperationMetadata_Step.toJSON(e) : undefined);
    } else {
      obj.steps = [];
    }
    message.progressPercentage !== undefined && (obj.progressPercentage = Math.round(message.progressPercentage));
    message.startTime !== undefined && (obj.startTime = message.startTime.toISOString());
    return obj;
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.resourceNames = object.resourceNames?.map(e => e) || [];
    message.steps = object.steps?.map(e => OperationMetadata_Step.fromPartial(e)) || [];
    message.progressPercentage = object.progressPercentage ?? 0;
    message.startTime = object.startTime ?? undefined;
    return message;
  },
  fromSDK(object: OperationMetadataSDKType): OperationMetadata {
    return {
      resourceNames: Array.isArray(object?.resource_names) ? object.resource_names.map((e: any) => e) : [],
      steps: Array.isArray(object?.steps) ? object.steps.map((e: any) => OperationMetadata_Step.fromSDK(e)) : [],
      progressPercentage: object?.progress_percentage,
      startTime: object.start_time ?? undefined
    };
  },
  toSDK(message: OperationMetadata): OperationMetadataSDKType {
    const obj: any = {};
    if (message.resourceNames) {
      obj.resource_names = message.resourceNames.map(e => e);
    } else {
      obj.resource_names = [];
    }
    if (message.steps) {
      obj.steps = message.steps.map(e => e ? OperationMetadata_Step.toSDK(e) : undefined);
    } else {
      obj.steps = [];
    }
    obj.progress_percentage = message.progressPercentage;
    message.startTime !== undefined && (obj.start_time = message.startTime ?? undefined);
    return obj;
  },
  fromAmino(object: OperationMetadataAmino): OperationMetadata {
    return {
      resourceNames: Array.isArray(object?.resource_names) ? object.resource_names.map((e: any) => e) : [],
      steps: Array.isArray(object?.steps) ? object.steps.map((e: any) => OperationMetadata_Step.fromAmino(e)) : [],
      progressPercentage: object.progress_percentage,
      startTime: object?.start_time ? Timestamp.fromAmino(object.start_time) : undefined
    };
  },
  toAmino(message: OperationMetadata): OperationMetadataAmino {
    const obj: any = {};
    if (message.resourceNames) {
      obj.resource_names = message.resourceNames.map(e => e);
    } else {
      obj.resource_names = [];
    }
    if (message.steps) {
      obj.steps = message.steps.map(e => e ? OperationMetadata_Step.toAmino(e) : undefined);
    } else {
      obj.steps = [];
    }
    obj.progress_percentage = message.progressPercentage;
    obj.start_time = message.startTime ? Timestamp.toAmino(message.startTime) : undefined;
    return obj;
  },
  fromAminoMsg(object: OperationMetadataAminoMsg): OperationMetadata {
    return OperationMetadata.fromAmino(object.value);
  },
  fromProtoMsg(message: OperationMetadataProtoMsg): OperationMetadata {
    return OperationMetadata.decode(message.value);
  },
  toProto(message: OperationMetadata): Uint8Array {
    return OperationMetadata.encode(message).finish();
  },
  toProtoMsg(message: OperationMetadata): OperationMetadataProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.OperationMetadata",
      value: OperationMetadata.encode(message).finish()
    };
  }
};
function createBaseOperationMetadata_Step(): OperationMetadata_Step {
  return {
    description: "",
    status: 0
  };
}
export const OperationMetadata_Step = {
  typeUrl: "/google.api.servicemanagement.v1.Step",
  encode(message: OperationMetadata_Step, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): OperationMetadata_Step {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata_Step();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.description = reader.string();
          break;
        case 4:
          message.status = (reader.int32() as any);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): OperationMetadata_Step {
    return {
      description: isSet(object.description) ? String(object.description) : "",
      status: isSet(object.status) ? operationMetadata_StatusFromJSON(object.status) : 0
    };
  },
  toJSON(message: OperationMetadata_Step): unknown {
    const obj: any = {};
    message.description !== undefined && (obj.description = message.description);
    message.status !== undefined && (obj.status = operationMetadata_StatusToJSON(message.status));
    return obj;
  },
  fromPartial(object: DeepPartial<OperationMetadata_Step>): OperationMetadata_Step {
    const message = createBaseOperationMetadata_Step();
    message.description = object.description ?? "";
    message.status = object.status ?? 0;
    return message;
  },
  fromSDK(object: OperationMetadata_StepSDKType): OperationMetadata_Step {
    return {
      description: object?.description,
      status: isSet(object.status) ? operationMetadata_StatusFromJSON(object.status) : 0
    };
  },
  toSDK(message: OperationMetadata_Step): OperationMetadata_StepSDKType {
    const obj: any = {};
    obj.description = message.description;
    message.status !== undefined && (obj.status = operationMetadata_StatusToJSON(message.status));
    return obj;
  },
  fromAmino(object: OperationMetadata_StepAmino): OperationMetadata_Step {
    return {
      description: object.description,
      status: isSet(object.status) ? operationMetadata_StatusFromJSON(object.status) : 0
    };
  },
  toAmino(message: OperationMetadata_Step): OperationMetadata_StepAmino {
    const obj: any = {};
    obj.description = message.description;
    obj.status = message.status;
    return obj;
  },
  fromAminoMsg(object: OperationMetadata_StepAminoMsg): OperationMetadata_Step {
    return OperationMetadata_Step.fromAmino(object.value);
  },
  fromProtoMsg(message: OperationMetadata_StepProtoMsg): OperationMetadata_Step {
    return OperationMetadata_Step.decode(message.value);
  },
  toProto(message: OperationMetadata_Step): Uint8Array {
    return OperationMetadata_Step.encode(message).finish();
  },
  toProtoMsg(message: OperationMetadata_Step): OperationMetadata_StepProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.Step",
      value: OperationMetadata_Step.encode(message).finish()
    };
  }
};
function createBaseDiagnostic(): Diagnostic {
  return {
    location: "",
    kind: 0,
    message: ""
  };
}
export const Diagnostic = {
  typeUrl: "/google.api.servicemanagement.v1.Diagnostic",
  encode(message: Diagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.kind !== 0) {
      writer.uint32(16).int32(message.kind);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): Diagnostic {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.location = reader.string();
          break;
        case 2:
          message.kind = (reader.int32() as any);
          break;
        case 3:
          message.message = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Diagnostic {
    return {
      location: isSet(object.location) ? String(object.location) : "",
      kind: isSet(object.kind) ? diagnostic_KindFromJSON(object.kind) : 0,
      message: isSet(object.message) ? String(object.message) : ""
    };
  },
  toJSON(message: Diagnostic): unknown {
    const obj: any = {};
    message.location !== undefined && (obj.location = message.location);
    message.kind !== undefined && (obj.kind = diagnostic_KindToJSON(message.kind));
    message.message !== undefined && (obj.message = message.message);
    return obj;
  },
  fromPartial(object: DeepPartial<Diagnostic>): Diagnostic {
    const message = createBaseDiagnostic();
    message.location = object.location ?? "";
    message.kind = object.kind ?? 0;
    message.message = object.message ?? "";
    return message;
  },
  fromSDK(object: DiagnosticSDKType): Diagnostic {
    return {
      location: object?.location,
      kind: isSet(object.kind) ? diagnostic_KindFromJSON(object.kind) : 0,
      message: object?.message
    };
  },
  toSDK(message: Diagnostic): DiagnosticSDKType {
    const obj: any = {};
    obj.location = message.location;
    message.kind !== undefined && (obj.kind = diagnostic_KindToJSON(message.kind));
    obj.message = message.message;
    return obj;
  },
  fromAmino(object: DiagnosticAmino): Diagnostic {
    return {
      location: object.location,
      kind: isSet(object.kind) ? diagnostic_KindFromJSON(object.kind) : 0,
      message: object.message
    };
  },
  toAmino(message: Diagnostic): DiagnosticAmino {
    const obj: any = {};
    obj.location = message.location;
    obj.kind = message.kind;
    obj.message = message.message;
    return obj;
  },
  fromAminoMsg(object: DiagnosticAminoMsg): Diagnostic {
    return Diagnostic.fromAmino(object.value);
  },
  fromProtoMsg(message: DiagnosticProtoMsg): Diagnostic {
    return Diagnostic.decode(message.value);
  },
  toProto(message: Diagnostic): Uint8Array {
    return Diagnostic.encode(message).finish();
  },
  toProtoMsg(message: Diagnostic): DiagnosticProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.Diagnostic",
      value: Diagnostic.encode(message).finish()
    };
  }
};
function createBaseConfigSource(): ConfigSource {
  return {
    id: "",
    files: []
  };
}
export const ConfigSource = {
  typeUrl: "/google.api.servicemanagement.v1.ConfigSource",
  encode(message: ConfigSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    for (const v of message.files) {
      ConfigFile.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigSource {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          message.id = reader.string();
          break;
        case 2:
          message.files.push(ConfigFile.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ConfigSource {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      files: Array.isArray(object?.files) ? object.files.map((e: any) => ConfigFile.fromJSON(e)) : []
    };
  },
  toJSON(message: ConfigSource): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    if (message.files) {
      obj.files = message.files.map(e => e ? ConfigFile.toJSON(e) : undefined);
    } else {
      obj.files = [];
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ConfigSource>): ConfigSource {
    const message = createBaseConfigSource();
    message.id = object.id ?? "";
    message.files = object.files?.map(e => ConfigFile.fromPartial(e)) || [];
    return message;
  },
  fromSDK(object: ConfigSourceSDKType): ConfigSource {
    return {
      id: object?.id,
      files: Array.isArray(object?.files) ? object.files.map((e: any) => ConfigFile.fromSDK(e)) : []
    };
  },
  toSDK(message: ConfigSource): ConfigSourceSDKType {
    const obj: any = {};
    obj.id = message.id;
    if (message.files) {
      obj.files = message.files.map(e => e ? ConfigFile.toSDK(e) : undefined);
    } else {
      obj.files = [];
    }
    return obj;
  },
  fromAmino(object: ConfigSourceAmino): ConfigSource {
    return {
      id: object.id,
      files: Array.isArray(object?.files) ? object.files.map((e: any) => ConfigFile.fromAmino(e)) : []
    };
  },
  toAmino(message: ConfigSource): ConfigSourceAmino {
    const obj: any = {};
    obj.id = message.id;
    if (message.files) {
      obj.files = message.files.map(e => e ? ConfigFile.toAmino(e) : undefined);
    } else {
      obj.files = [];
    }
    return obj;
  },
  fromAminoMsg(object: ConfigSourceAminoMsg): ConfigSource {
    return ConfigSource.fromAmino(object.value);
  },
  fromProtoMsg(message: ConfigSourceProtoMsg): ConfigSource {
    return ConfigSource.decode(message.value);
  },
  toProto(message: ConfigSource): Uint8Array {
    return ConfigSource.encode(message).finish();
  },
  toProtoMsg(message: ConfigSource): ConfigSourceProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.ConfigSource",
      value: ConfigSource.encode(message).finish()
    };
  }
};
function createBaseConfigFile(): ConfigFile {
  return {
    filePath: "",
    fileContents: new Uint8Array(),
    fileType: 0
  };
}
export const ConfigFile = {
  typeUrl: "/google.api.servicemanagement.v1.ConfigFile",
  encode(message: ConfigFile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.fileContents.length !== 0) {
      writer.uint32(26).bytes(message.fileContents);
    }
    if (message.fileType !== 0) {
      writer.uint32(32).int32(message.fileType);
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigFile {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filePath = reader.string();
          break;
        case 3:
          message.fileContents = reader.bytes();
          break;
        case 4:
          message.fileType = (reader.int32() as any);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ConfigFile {
    return {
      filePath: isSet(object.filePath) ? String(object.filePath) : "",
      fileContents: isSet(object.fileContents) ? bytesFromBase64(object.fileContents) : new Uint8Array(),
      fileType: isSet(object.fileType) ? configFile_FileTypeFromJSON(object.fileType) : 0
    };
  },
  toJSON(message: ConfigFile): unknown {
    const obj: any = {};
    message.filePath !== undefined && (obj.filePath = message.filePath);
    message.fileContents !== undefined && (obj.fileContents = base64FromBytes(message.fileContents !== undefined ? message.fileContents : new Uint8Array()));
    message.fileType !== undefined && (obj.fileType = configFile_FileTypeToJSON(message.fileType));
    return obj;
  },
  fromPartial(object: DeepPartial<ConfigFile>): ConfigFile {
    const message = createBaseConfigFile();
    message.filePath = object.filePath ?? "";
    message.fileContents = object.fileContents ?? new Uint8Array();
    message.fileType = object.fileType ?? 0;
    return message;
  },
  fromSDK(object: ConfigFileSDKType): ConfigFile {
    return {
      filePath: object?.file_path,
      fileContents: object?.file_contents,
      fileType: isSet(object.file_type) ? configFile_FileTypeFromJSON(object.file_type) : 0
    };
  },
  toSDK(message: ConfigFile): ConfigFileSDKType {
    const obj: any = {};
    obj.file_path = message.filePath;
    obj.file_contents = message.fileContents;
    message.fileType !== undefined && (obj.file_type = configFile_FileTypeToJSON(message.fileType));
    return obj;
  },
  fromAmino(object: ConfigFileAmino): ConfigFile {
    return {
      filePath: object.file_path,
      fileContents: object.file_contents,
      fileType: isSet(object.file_type) ? configFile_FileTypeFromJSON(object.file_type) : 0
    };
  },
  toAmino(message: ConfigFile): ConfigFileAmino {
    const obj: any = {};
    obj.file_path = message.filePath;
    obj.file_contents = message.fileContents;
    obj.file_type = message.fileType;
    return obj;
  },
  fromAminoMsg(object: ConfigFileAminoMsg): ConfigFile {
    return ConfigFile.fromAmino(object.value);
  },
  fromProtoMsg(message: ConfigFileProtoMsg): ConfigFile {
    return ConfigFile.decode(message.value);
  },
  toProto(message: ConfigFile): Uint8Array {
    return ConfigFile.encode(message).finish();
  },
  toProtoMsg(message: ConfigFile): ConfigFileProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.ConfigFile",
      value: ConfigFile.encode(message).finish()
    };
  }
};
function createBaseConfigRef(): ConfigRef {
  return {
    name: ""
  };
}
export const ConfigRef = {
  typeUrl: "/google.api.servicemanagement.v1.ConfigRef",
  encode(message: ConfigRef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigRef {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ConfigRef {
    return {
      name: isSet(object.name) ? String(object.name) : ""
    };
  },
  toJSON(message: ConfigRef): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },
  fromPartial(object: DeepPartial<ConfigRef>): ConfigRef {
    const message = createBaseConfigRef();
    message.name = object.name ?? "";
    return message;
  },
  fromSDK(object: ConfigRefSDKType): ConfigRef {
    return {
      name: object?.name
    };
  },
  toSDK(message: ConfigRef): ConfigRefSDKType {
    const obj: any = {};
    obj.name = message.name;
    return obj;
  },
  fromAmino(object: ConfigRefAmino): ConfigRef {
    return {
      name: object.name
    };
  },
  toAmino(message: ConfigRef): ConfigRefAmino {
    const obj: any = {};
    obj.name = message.name;
    return obj;
  },
  fromAminoMsg(object: ConfigRefAminoMsg): ConfigRef {
    return ConfigRef.fromAmino(object.value);
  },
  fromProtoMsg(message: ConfigRefProtoMsg): ConfigRef {
    return ConfigRef.decode(message.value);
  },
  toProto(message: ConfigRef): Uint8Array {
    return ConfigRef.encode(message).finish();
  },
  toProtoMsg(message: ConfigRef): ConfigRefProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.ConfigRef",
      value: ConfigRef.encode(message).finish()
    };
  }
};
function createBaseChangeReport(): ChangeReport {
  return {
    configChanges: []
  };
}
export const ChangeReport = {
  typeUrl: "/google.api.servicemanagement.v1.ChangeReport",
  encode(message: ChangeReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.configChanges) {
      ConfigChange.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): ChangeReport {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configChanges.push(ConfigChange.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ChangeReport {
    return {
      configChanges: Array.isArray(object?.configChanges) ? object.configChanges.map((e: any) => ConfigChange.fromJSON(e)) : []
    };
  },
  toJSON(message: ChangeReport): unknown {
    const obj: any = {};
    if (message.configChanges) {
      obj.configChanges = message.configChanges.map(e => e ? ConfigChange.toJSON(e) : undefined);
    } else {
      obj.configChanges = [];
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ChangeReport>): ChangeReport {
    const message = createBaseChangeReport();
    message.configChanges = object.configChanges?.map(e => ConfigChange.fromPartial(e)) || [];
    return message;
  },
  fromSDK(object: ChangeReportSDKType): ChangeReport {
    return {
      configChanges: Array.isArray(object?.config_changes) ? object.config_changes.map((e: any) => ConfigChange.fromSDK(e)) : []
    };
  },
  toSDK(message: ChangeReport): ChangeReportSDKType {
    const obj: any = {};
    if (message.configChanges) {
      obj.config_changes = message.configChanges.map(e => e ? ConfigChange.toSDK(e) : undefined);
    } else {
      obj.config_changes = [];
    }
    return obj;
  },
  fromAmino(object: ChangeReportAmino): ChangeReport {
    return {
      configChanges: Array.isArray(object?.config_changes) ? object.config_changes.map((e: any) => ConfigChange.fromAmino(e)) : []
    };
  },
  toAmino(message: ChangeReport): ChangeReportAmino {
    const obj: any = {};
    if (message.configChanges) {
      obj.config_changes = message.configChanges.map(e => e ? ConfigChange.toAmino(e) : undefined);
    } else {
      obj.config_changes = [];
    }
    return obj;
  },
  fromAminoMsg(object: ChangeReportAminoMsg): ChangeReport {
    return ChangeReport.fromAmino(object.value);
  },
  fromProtoMsg(message: ChangeReportProtoMsg): ChangeReport {
    return ChangeReport.decode(message.value);
  },
  toProto(message: ChangeReport): Uint8Array {
    return ChangeReport.encode(message).finish();
  },
  toProtoMsg(message: ChangeReport): ChangeReportProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.ChangeReport",
      value: ChangeReport.encode(message).finish()
    };
  }
};
function createBaseRollout(): Rollout {
  return {
    rolloutId: "",
    createTime: undefined,
    createdBy: "",
    status: 0,
    trafficPercentStrategy: undefined,
    deleteServiceStrategy: undefined,
    serviceName: ""
  };
}
export const Rollout = {
  typeUrl: "/google.api.servicemanagement.v1.Rollout",
  encode(message: Rollout, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rolloutId !== "") {
      writer.uint32(10).string(message.rolloutId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).ldelim();
    }
    if (message.createdBy !== "") {
      writer.uint32(26).string(message.createdBy);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.trafficPercentStrategy !== undefined) {
      Rollout_TrafficPercentStrategy.encode(message.trafficPercentStrategy, writer.uint32(42).fork()).ldelim();
    }
    if (message.deleteServiceStrategy !== undefined) {
      Rollout_DeleteServiceStrategy.encode(message.deleteServiceStrategy, writer.uint32(1602).fork()).ldelim();
    }
    if (message.serviceName !== "") {
      writer.uint32(66).string(message.serviceName);
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): Rollout {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rolloutId = reader.string();
          break;
        case 2:
          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.createdBy = reader.string();
          break;
        case 4:
          message.status = (reader.int32() as any);
          break;
        case 5:
          message.trafficPercentStrategy = Rollout_TrafficPercentStrategy.decode(reader, reader.uint32());
          break;
        case 200:
          message.deleteServiceStrategy = Rollout_DeleteServiceStrategy.decode(reader, reader.uint32());
          break;
        case 8:
          message.serviceName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Rollout {
    return {
      rolloutId: isSet(object.rolloutId) ? String(object.rolloutId) : "",
      createTime: isSet(object.createTime) ? new Date(object.createTime) : undefined,
      createdBy: isSet(object.createdBy) ? String(object.createdBy) : "",
      status: isSet(object.status) ? rollout_RolloutStatusFromJSON(object.status) : 0,
      trafficPercentStrategy: isSet(object.trafficPercentStrategy) ? Rollout_TrafficPercentStrategy.fromJSON(object.trafficPercentStrategy) : undefined,
      deleteServiceStrategy: isSet(object.deleteServiceStrategy) ? Rollout_DeleteServiceStrategy.fromJSON(object.deleteServiceStrategy) : undefined,
      serviceName: isSet(object.serviceName) ? String(object.serviceName) : ""
    };
  },
  toJSON(message: Rollout): unknown {
    const obj: any = {};
    message.rolloutId !== undefined && (obj.rolloutId = message.rolloutId);
    message.createTime !== undefined && (obj.createTime = message.createTime.toISOString());
    message.createdBy !== undefined && (obj.createdBy = message.createdBy);
    message.status !== undefined && (obj.status = rollout_RolloutStatusToJSON(message.status));
    message.trafficPercentStrategy !== undefined && (obj.trafficPercentStrategy = message.trafficPercentStrategy ? Rollout_TrafficPercentStrategy.toJSON(message.trafficPercentStrategy) : undefined);
    message.deleteServiceStrategy !== undefined && (obj.deleteServiceStrategy = message.deleteServiceStrategy ? Rollout_DeleteServiceStrategy.toJSON(message.deleteServiceStrategy) : undefined);
    message.serviceName !== undefined && (obj.serviceName = message.serviceName);
    return obj;
  },
  fromPartial(object: DeepPartial<Rollout>): Rollout {
    const message = createBaseRollout();
    message.rolloutId = object.rolloutId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.createdBy = object.createdBy ?? "";
    message.status = object.status ?? 0;
    message.trafficPercentStrategy = object.trafficPercentStrategy !== undefined && object.trafficPercentStrategy !== null ? Rollout_TrafficPercentStrategy.fromPartial(object.trafficPercentStrategy) : undefined;
    message.deleteServiceStrategy = object.deleteServiceStrategy !== undefined && object.deleteServiceStrategy !== null ? Rollout_DeleteServiceStrategy.fromPartial(object.deleteServiceStrategy) : undefined;
    message.serviceName = object.serviceName ?? "";
    return message;
  },
  fromSDK(object: RolloutSDKType): Rollout {
    return {
      rolloutId: object?.rollout_id,
      createTime: object.create_time ?? undefined,
      createdBy: object?.created_by,
      status: isSet(object.status) ? rollout_RolloutStatusFromJSON(object.status) : 0,
      trafficPercentStrategy: object.traffic_percent_strategy ? Rollout_TrafficPercentStrategy.fromSDK(object.traffic_percent_strategy) : undefined,
      deleteServiceStrategy: object.delete_service_strategy ? Rollout_DeleteServiceStrategy.fromSDK(object.delete_service_strategy) : undefined,
      serviceName: object?.service_name
    };
  },
  toSDK(message: Rollout): RolloutSDKType {
    const obj: any = {};
    obj.rollout_id = message.rolloutId;
    message.createTime !== undefined && (obj.create_time = message.createTime ?? undefined);
    obj.created_by = message.createdBy;
    message.status !== undefined && (obj.status = rollout_RolloutStatusToJSON(message.status));
    message.trafficPercentStrategy !== undefined && (obj.traffic_percent_strategy = message.trafficPercentStrategy ? Rollout_TrafficPercentStrategy.toSDK(message.trafficPercentStrategy) : undefined);
    message.deleteServiceStrategy !== undefined && (obj.delete_service_strategy = message.deleteServiceStrategy ? Rollout_DeleteServiceStrategy.toSDK(message.deleteServiceStrategy) : undefined);
    obj.service_name = message.serviceName;
    return obj;
  },
  fromAmino(object: RolloutAmino): Rollout {
    return {
      rolloutId: object.rollout_id,
      createTime: object?.create_time ? Timestamp.fromAmino(object.create_time) : undefined,
      createdBy: object.created_by,
      status: isSet(object.status) ? rollout_RolloutStatusFromJSON(object.status) : 0,
      trafficPercentStrategy: object?.traffic_percent_strategy ? Rollout_TrafficPercentStrategy.fromAmino(object.traffic_percent_strategy) : undefined,
      deleteServiceStrategy: object?.delete_service_strategy ? Rollout_DeleteServiceStrategy.fromAmino(object.delete_service_strategy) : undefined,
      serviceName: object.service_name
    };
  },
  toAmino(message: Rollout): RolloutAmino {
    const obj: any = {};
    obj.rollout_id = message.rolloutId;
    obj.create_time = message.createTime ? Timestamp.toAmino(message.createTime) : undefined;
    obj.created_by = message.createdBy;
    obj.status = message.status;
    obj.traffic_percent_strategy = message.trafficPercentStrategy ? Rollout_TrafficPercentStrategy.toAmino(message.trafficPercentStrategy) : undefined;
    obj.delete_service_strategy = message.deleteServiceStrategy ? Rollout_DeleteServiceStrategy.toAmino(message.deleteServiceStrategy) : undefined;
    obj.service_name = message.serviceName;
    return obj;
  },
  fromAminoMsg(object: RolloutAminoMsg): Rollout {
    return Rollout.fromAmino(object.value);
  },
  fromProtoMsg(message: RolloutProtoMsg): Rollout {
    return Rollout.decode(message.value);
  },
  toProto(message: Rollout): Uint8Array {
    return Rollout.encode(message).finish();
  },
  toProtoMsg(message: Rollout): RolloutProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.Rollout",
      value: Rollout.encode(message).finish()
    };
  }
};
function createBaseRollout_TrafficPercentStrategy_PercentagesEntry(): Rollout_TrafficPercentStrategy_PercentagesEntry {
  return {
    key: "",
    value: 0
  };
}
export const Rollout_TrafficPercentStrategy_PercentagesEntry = {
  encode(message: Rollout_TrafficPercentStrategy_PercentagesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): Rollout_TrafficPercentStrategy_PercentagesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout_TrafficPercentStrategy_PercentagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Rollout_TrafficPercentStrategy_PercentagesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Number(object.value) : 0
    };
  },
  toJSON(message: Rollout_TrafficPercentStrategy_PercentagesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },
  fromPartial(object: DeepPartial<Rollout_TrafficPercentStrategy_PercentagesEntry>): Rollout_TrafficPercentStrategy_PercentagesEntry {
    const message = createBaseRollout_TrafficPercentStrategy_PercentagesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
  fromSDK(object: Rollout_TrafficPercentStrategy_PercentagesEntrySDKType): Rollout_TrafficPercentStrategy_PercentagesEntry {
    return {
      key: object?.key,
      value: object?.value
    };
  },
  toSDK(message: Rollout_TrafficPercentStrategy_PercentagesEntry): Rollout_TrafficPercentStrategy_PercentagesEntrySDKType {
    const obj: any = {};
    obj.key = message.key;
    obj.value = message.value;
    return obj;
  },
  fromAmino(object: Rollout_TrafficPercentStrategy_PercentagesEntryAmino): Rollout_TrafficPercentStrategy_PercentagesEntry {
    return {
      key: object.key,
      value: object.value
    };
  },
  toAmino(message: Rollout_TrafficPercentStrategy_PercentagesEntry): Rollout_TrafficPercentStrategy_PercentagesEntryAmino {
    const obj: any = {};
    obj.key = message.key;
    obj.value = message.value;
    return obj;
  },
  fromAminoMsg(object: Rollout_TrafficPercentStrategy_PercentagesEntryAminoMsg): Rollout_TrafficPercentStrategy_PercentagesEntry {
    return Rollout_TrafficPercentStrategy_PercentagesEntry.fromAmino(object.value);
  },
  fromProtoMsg(message: Rollout_TrafficPercentStrategy_PercentagesEntryProtoMsg): Rollout_TrafficPercentStrategy_PercentagesEntry {
    return Rollout_TrafficPercentStrategy_PercentagesEntry.decode(message.value);
  },
  toProto(message: Rollout_TrafficPercentStrategy_PercentagesEntry): Uint8Array {
    return Rollout_TrafficPercentStrategy_PercentagesEntry.encode(message).finish();
  }
};
function createBaseRollout_TrafficPercentStrategy(): Rollout_TrafficPercentStrategy {
  return {
    percentages: {}
  };
}
export const Rollout_TrafficPercentStrategy = {
  typeUrl: "/google.api.servicemanagement.v1.TrafficPercentStrategy",
  encode(message: Rollout_TrafficPercentStrategy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.percentages).forEach(([key, value]) => {
      Rollout_TrafficPercentStrategy_PercentagesEntry.encode({
        key: (key as any),
        value
      }, writer.uint32(9).fork()).ldelim();
    });
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): Rollout_TrafficPercentStrategy {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout_TrafficPercentStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = Rollout_TrafficPercentStrategy_PercentagesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.percentages[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Rollout_TrafficPercentStrategy {
    return {
      percentages: isObject(object.percentages) ? Object.entries(object.percentages).reduce<{
        [key: string]: double;
      }>((acc, [key, value]) => {
        acc[key] = double.fromJSON(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message: Rollout_TrafficPercentStrategy): unknown {
    const obj: any = {};
    obj.percentages = {};
    if (message.percentages) {
      Object.entries(message.percentages).forEach(([k, v]) => {
        obj.percentages[k] = double.toJSON(v);
      });
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Rollout_TrafficPercentStrategy>): Rollout_TrafficPercentStrategy {
    const message = createBaseRollout_TrafficPercentStrategy();
    message.percentages = Object.entries(object.percentages ?? {}).reduce<{
      [key: string]: double;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = double.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
  fromSDK(object: Rollout_TrafficPercentStrategySDKType): Rollout_TrafficPercentStrategy {
    return {
      percentages: isObject(object.percentages) ? Object.entries(object.percentages).reduce<{
        [key: string]: double;
      }>((acc, [key, value]) => {
        acc[key] = double.fromSDK(value);
        return acc;
      }, {}) : {}
    };
  },
  toSDK(message: Rollout_TrafficPercentStrategy): Rollout_TrafficPercentStrategySDKType {
    const obj: any = {};
    obj.percentages = {};
    if (message.percentages) {
      Object.entries(message.percentages).forEach(([k, v]) => {
        obj.percentages[k] = double.toSDK(v);
      });
    }
    return obj;
  },
  fromAmino(object: Rollout_TrafficPercentStrategyAmino): Rollout_TrafficPercentStrategy {
    return {
      percentages: isObject(object.percentages) ? Object.entries(object.percentages).reduce<{
        [key: string]: double;
      }>((acc, [key, value]) => {
        acc[key] = double.fromAmino(value);
        return acc;
      }, {}) : {}
    };
  },
  toAmino(message: Rollout_TrafficPercentStrategy): Rollout_TrafficPercentStrategyAmino {
    const obj: any = {};
    obj.percentages = {};
    if (message.percentages) {
      Object.entries(message.percentages).forEach(([k, v]) => {
        obj.percentages[k] = double.toAmino(v);
      });
    }
    return obj;
  },
  fromAminoMsg(object: Rollout_TrafficPercentStrategyAminoMsg): Rollout_TrafficPercentStrategy {
    return Rollout_TrafficPercentStrategy.fromAmino(object.value);
  },
  fromProtoMsg(message: Rollout_TrafficPercentStrategyProtoMsg): Rollout_TrafficPercentStrategy {
    return Rollout_TrafficPercentStrategy.decode(message.value);
  },
  toProto(message: Rollout_TrafficPercentStrategy): Uint8Array {
    return Rollout_TrafficPercentStrategy.encode(message).finish();
  },
  toProtoMsg(message: Rollout_TrafficPercentStrategy): Rollout_TrafficPercentStrategyProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.TrafficPercentStrategy",
      value: Rollout_TrafficPercentStrategy.encode(message).finish()
    };
  }
};
function createBaseRollout_DeleteServiceStrategy(): Rollout_DeleteServiceStrategy {
  return {};
}
export const Rollout_DeleteServiceStrategy = {
  typeUrl: "/google.api.servicemanagement.v1.DeleteServiceStrategy",
  encode(_: Rollout_DeleteServiceStrategy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },
  decode(input: _m0.Reader | Uint8Array, length?: number): Rollout_DeleteServiceStrategy {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout_DeleteServiceStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_: any): Rollout_DeleteServiceStrategy {
    return {};
  },
  toJSON(_: Rollout_DeleteServiceStrategy): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<Rollout_DeleteServiceStrategy>): Rollout_DeleteServiceStrategy {
    const message = createBaseRollout_DeleteServiceStrategy();
    return message;
  },
  fromSDK(_: Rollout_DeleteServiceStrategySDKType): Rollout_DeleteServiceStrategy {
    return {};
  },
  toSDK(_: Rollout_DeleteServiceStrategy): Rollout_DeleteServiceStrategySDKType {
    const obj: any = {};
    return obj;
  },
  fromAmino(_: Rollout_DeleteServiceStrategyAmino): Rollout_DeleteServiceStrategy {
    return {};
  },
  toAmino(_: Rollout_DeleteServiceStrategy): Rollout_DeleteServiceStrategyAmino {
    const obj: any = {};
    return obj;
  },
  fromAminoMsg(object: Rollout_DeleteServiceStrategyAminoMsg): Rollout_DeleteServiceStrategy {
    return Rollout_DeleteServiceStrategy.fromAmino(object.value);
  },
  fromProtoMsg(message: Rollout_DeleteServiceStrategyProtoMsg): Rollout_DeleteServiceStrategy {
    return Rollout_DeleteServiceStrategy.decode(message.value);
  },
  toProto(message: Rollout_DeleteServiceStrategy): Uint8Array {
    return Rollout_DeleteServiceStrategy.encode(message).finish();
  },
  toProtoMsg(message: Rollout_DeleteServiceStrategy): Rollout_DeleteServiceStrategyProtoMsg {
    return {
      typeUrl: "/google.api.servicemanagement.v1.DeleteServiceStrategy",
      value: Rollout_DeleteServiceStrategy.encode(message).finish()
    };
  }
};